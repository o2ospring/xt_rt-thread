/**
  * @file  app_ir_huilink.c
  * @brief 红外解码（改自深圳市辉联智控科技有限公司的红外压缩码的解码模块）
  * COPYRIGHT (C) 2022, XT 技术联合小组
  * Change Logs:
  * Date           Author       Notes
  * 2022-11-26     o2ospring    原始版本
  */
#define   APP_IR_HUILINK_C__
#include "app_ir_huilink.h"
#if (defined(XT_APP_DEBUG) && ((XT_APP_DEBUG == 20221126) || (XT_APP_DEBUG == 20221203) || (XT_APP_DEBUG == 20221216)))
#if (defined(XT_APP_IRSEND_EN) && (XT_APP_IRSEND_EN == XT_DEF_ENABLED))
#ifdef    APP_IR_HUILINK_X__ 
#undef    APP_IR_HUILINK_H__
#include "app_ir_huilink.h"
#endif

//全局变量
#define APP_SW_UC_TO_US(d2,d1) ((((uint16_t)(d2) & 0xFF) << 8) | ((uint16_t)(d1) & 0xFF))
const uint8_t pwda[] ={0x88,0x9E,0xA3,0x31,0x72,0xEE,0xDC,0x50,0x0E,0xA7,0x94,0xEB,0x34,0x7A,0xB9,0x12,0x8F,0xAB,0x87,0xCE,0x20,0xC2,0x7E,0x85,0x11,0x6B,0xC7,0x62,0x2F,0x73,0x06,0xDD,0x69,0x6A,0x4D,0x84,0xE3,0x29,0x17,0x25,0x10,0x0F,0x08,0x3E,0x4F,0xE9,0x36,0x38,0x0D,0x82,0xA6,0xB4,0x7F,0x04,0x63,0xC9,0x22,0x66,0x6F,0x86,0x3F,0x59,0xDE,0x47,0x77,0xDB,0xC6,0x58,0x7B,0x8C,0x9A,0xC5,0x83,0x23,0xD4,0xB1,0xA8,0xAF,0xFA,0xAE,0x43,0x1E,0xF0,0xEF,0xC0,0x26,0x07,0x79,0x75,0x2A,0xBD,0x27,0xD7,0xDA,0xAC,0xAA,0xE1,0xE6,0xDF,0x89,0xC4,0x92,0x6E,0xE8,0xF9,0x56,0xB3,0xA2,0x44,0xD5,0xCC,0x1D,0x71,0xCD,0x45,0x70,0x51,0x68,0xFB,0x4B,0x97,0x65,0x2C,0x6C,0x0A,0xC3,0xFC,0xD3,0x09,0x46,0x95,0xED,0xE0,0x8A,0xB6,0x2E,0xE7,0x7D,0x42,0xCA,0x53,0x5C,0x4C,0x93,0xD8,0x49,0x96,0xF2,0xD6,0x6D,0x1C,0x14,0x91,0x35,0x3D,0xD9,0x21,0xE4,0x8B,0x18,0x40,0x98,0x37,0xFD,0x9B,0xF7,0xA1,0x2D,0xBC,0x55,0x4A,0x33,0x9D,0x24,0xF6,0xB7,0x39,0x99,0x8E,0x5E,0xBF,0x41,0xFF,0x19,0x02,0xCF,0xBA,0x3C,0x28,0xE5,0x15,0x5D,0x30,0x5B,0xD2,0xEA,0xA9,0x81,0xB8,0x61,0x05,0x2B,0x13,0xD0,0xAD,0x3B,0xF4,0x01,0x0B,0xA0,0x90,0xFE,0x1B,0x64,0x1A,0x16,0xC1,0x67,0x5F,0xF1,0xF8,0x48,0x3A,0x60,0x54,0xB0,0xCB,0x8D,0x9C,0xA4,0xB2,0x0C,0xF5,0xF3,0x00,0x32,0xC8,0x57,0xEC,0x74,0x4E,0x7C,0x76,0xBE,0x80,0xA5,0xB5,0xE2,0x9F,0x1F,0xD1,0x5A,0x52,0xBB,0x03,0x78};
const uint8_t pwdb[] ={0x89,0x9A,0xB0,0x09,0xE9,0x84,0x26,0x7E,0x7C,0x55,0x92,0xF3,0x1E,0xBA,0xEC,0x6C,0x72,0x11,0x76,0x14,0x73,0xB7,0xA0,0x1F,0xF5,0x12,0xA8,0xBE,0xE2,0x21,0xEF,0xA5,0x33,0x2E,0xFF,0x29,0x38,0x70,0x8A,0xF4,0xB9,0xE1,0x82,0xE4,0xDB,0xEB,0x1D,0x52,0xFD,0x98,0x64,0xAD,0x93,0x36,0x4E,0x3E,0x5B,0x3D,0x04,0xA4,0xA9,0x17,0x1B,0xA7,0xD8,0x78,0x71,0x99,0x19,0x01,0x6F,0x8B,0x79,0xA3,0x77,0x24,0xF2,0x85,0xC6,0x31,0x9B,0xC3,0x8D,0x37,0xA6,0xD2,0x35,0x83,0xFE,0x6D,0xFA,0x4A,0x62,0xF1,0x69,0x03,0x6A,0x0F,0x42,0x97,0x43,0x4B,0x53,0x91,0xCB,0x5E,0xD7,0x68,0x34,0x8E,0x7D,0xCD,0x57,0x95,0x39,0x2A,0x49,0x06,0x1A,0x63,0xE5,0x0D,0x66,0x5F,0x32,0xB4,0x54,0xD3,0x44,0x65,0x9C,0xD9,0x9F,0xD1,0x60,0x05,0x3B,0x13,0xC5,0x46,0x41,0xF6,0xC0,0xBD,0xCA,0x08,0xFC,0x9D,0x0A,0xD0,0xBF,0x6B,0x67,0x27,0xAC,0x61,0x9E,0x59,0x7B,0x0B,0x5A,0xC7,0x15,0x86,0xEE,0x48,0x1C,0xE3,0x47,0xEA,0x8F,0x2F,0xC8,0x2B,0x87,0xC1,0x22,0xF7,0x5D,0x07,0x56,0xC4,0xF8,0xE0,0x10,0xAF,0x8C,0xCF,0x00,0x02,0xF9,0x16,0xD6,0x23,0x4F,0x58,0x75,0x7F,0x0C,0xD4,0x2D,0xE7,0xE8,0x0E,0x7A,0xAE,0xB8,0x88,0x30,0x90,0x45,0xB2,0x40,0xE6,0x74,0xAA,0xB3,0x5C,0xED,0xBB,0xDE,0x4C,0xB5,0x3A,0x51,0x3C,0xC2,0x50,0xB6,0xA2,0x3F,0xF0,0x2C,0xDC,0xDA,0x94,0xDF,0xAB,0x28,0x81,0xBC,0xFB,0x25,0xB1,0xCC,0xA1,0xD5,0x18,0x80,0x96,0xC9,0xCE,0x20,0x6E,0x4D,0xDD};
const uint8_t pwdc[] ={0x80,0x54,0xA3,0xCE,0xB2,0xCB,0x6B,0x4A,0x3E,0xB1,0x96,0x8C,0x7A,0x08,0x99,0x18,0x0E,0x33,0x30,0x8D,0x15,0x13,0x51,0xB4,0x3B,0x7E,0xAD,0x59,0x65,0x60,0x4E,0x6E,0xF2,0x3A,0xF7,0xCC,0x27,0x52,0x26,0xF3,0xD8,0x35,0x24,0xEB,0xDF,0x90,0x86,0x9D,0x38,0xF9,0x31,0x0D,0x5F,0x87,0x3F,0xE8,0xD1,0xE9,0x8E,0xA6,0xBA,0xEA,0xC8,0x36,0xA7,0xC1,0x6D,0x5E,0x82,0xEC,0x4C,0xB0,0xDB,0xA8,0x00,0x17,0x4B,0x32,0x37,0xA2,0x91,0xA0,0x34,0x58,0x92,0x03,0xE6,0x8B,0xFA,0xE0,0x5D,0xC4,0xDA,0x95,0xEE,0x45,0xD0,0xDD,0x70,0xFC,0xB8,0x0C,0xCA,0xCF,0xBF,0x3D,0x5A,0xC3,0xC0,0xF8,0x76,0xAB,0xFB,0x40,0x44,0xB6,0x71,0xD7,0xE7,0x3C,0x8F,0x79,0x84,0xC7,0x66,0x22,0x20,0x41,0x25,0x9C,0x2F,0x74,0xC9,0x9F,0x29,0x1E,0x7C,0xED,0x55,0x63,0xDE,0x2C,0x16,0x19,0x6F,0x05,0xE3,0x6C,0xA1,0x0B,0x4F,0x53,0x2E,0x09,0x46,0xC2,0x85,0x62,0xF4,0x88,0x9B,0x69,0xB9,0x1A,0x68,0x81,0xBE,0xD2,0xB3,0x93,0xF0,0x39,0x4D,0x5C,0x1C,0x67,0x1B,0x56,0x47,0x7D,0x61,0x97,0x49,0x7B,0xC5,0xCD,0xAE,0x06,0xFE,0x2D,0xA4,0x50,0x94,0x8A,0x73,0x04,0xA9,0x64,0x98,0xD4,0xAA,0xB5,0x43,0x57,0x1D,0xF1,0x78,0xC6,0xE5,0x89,0xE2,0x0F,0x07,0x7F,0x83,0xAC,0x42,0xFD,0x0A,0x28,0xAF,0xBD,0x12,0xDC,0x23,0x2B,0xF6,0xEF,0xD5,0xB7,0x9A,0xD6,0x75,0xF5,0x72,0x21,0xA5,0x1F,0x6A,0x5B,0x2A,0xE4,0x01,0x14,0x9E,0x48,0x77,0xBB,0x10,0xFF,0xE1,0xD9,0xD3,0x02,0xBC,0x11};

//函数声明
uint16_t Api_Ir_ConvCode(uint8_t *_SrcDat, uint16_t _Len);
uint16_t Api_Ir_DataSend(void *pob_tmp, uint16_t *p_code, uint16_t *p_step);

/**
  * @brief  初步解码
  * @param  *_SrcDat     数据源
  * @param  _Len         数据长度
  * @return 解码后的数据长度（长度不会变大）
  */
uint16_t Api_Ir_ConvCode(uint8_t *_SrcDat, uint16_t _Len)
{
    uint8_t K1=0, K2=0, K3=0, pv=0;
//  int i;
//  static int scnt=0;

    K1 = _SrcDat[0];
    K2 = _Len-1;
    _SrcDat[0]=K2;  

    for (K3=1;K3<_Len;K3++) 
    {
      pv=(pwda[K3]+pwdb[K2]-pwdc[K1]) % 256;
      _SrcDat[K3]=_SrcDat[K3]^pv;
    }
    //2021-12-30 方案商要求屏蔽
    //if (_SrcDat[3]) 
    //{
    //  scnt+=1;  
    //  if (scnt % 2) 
    //  {
    //    if(_SrcDat[3]!=255)_SrcDat[_SrcDat[3]]=_SrcDat[_SrcDat[3]]^_SrcDat[4];
    //    else  
    //    {
    //      K1=_SrcDat[26];
    //      K2=_SrcDat[27];
    //      K3=_SrcDat[28];
    //      _SrcDat[26] = _SrcDat[29];
    //      _SrcDat[27] = _SrcDat[30];
    //      _SrcDat[28] = _SrcDat[31];
    //      _SrcDat[29] = _SrcDat[32];
    //      _SrcDat[30] = K1;
    //      _SrcDat[31] = K2;
    //      _SrcDat[32] = K3;
    //    }  
    //  } 
    //}
	return _Len; //增加数据长度返回
}

/**
  * @brief  一边发码一边解码
  * @param  *pob_tmp     为本函数提供全局空间（目前暂没有用到）
  * @param  *p_code      压缩码  （初步解码后的压缩码）
  * @param  *p_step      解码步骤（0:进来表刚开始/返回则表异常，0xFFFF:返回结束）
  * @return 解码后的数据（初次返回[红外时间码单位]和[红外载波频率]）
  */
const uint8_t  Math_2N_Table[] = {0x1,0x2,0x4,0x8,0x10,0x20,0x40,0x80};
uint16_t Api_Ir_DataSend(void *pob_tmp, uint16_t *p_code, uint16_t *p_step)
{
//  static uint16_t time_H;
//  static uint16_t time_L;
//  static uint16_t pbuf  = 0;
    static uint8_t cnt = 15;
    static uint8_t chr /*= _Data[15]*/;
    static uint8_t bytes = 0;
    static uint16_t bits = 0;
    static uint8_t Bytet;
    static uint8_t Bitt;
    static uint8_t j;
    static uint16_t i;
	uint16_t d;
	const uint8_t *_Data = (uint8_t *)p_code;
	
	///////////////////////////
	switch (*p_step)
	{
		case 1:  goto step______1;
		case 2:  goto step______2;
		case 3:  goto step______3;
		case 4:  goto step______4;
		case 5:  goto step______5;
		case 6:  goto step______6;
		case 7:  goto step______7;
		case 8:  goto step______8;
		case 9:  goto step______9;
		case 10: goto step______10;
		case 11: goto step______11;
		case 12: goto step______12;
		case 13: goto step______13;
		default: break;
	}
	cnt   = 15;
	chr   = _Data[15];
	bytes = 0;
	bits  = 0;
	///////////////////////////
	
   // taskENTER_CRITICAL();
   // time_H = ((uint16_t)_Data[cnt+1] << 8) + ((uint16_t)_Data[cnt+2]) - 0xc8;
   // time_L = ((uint16_t)_Data[cnt+5] << 8) + ((uint16_t)_Data[cnt+6]) - 0xC8;
    //SetPWMFreq(_Data[6]); //0x38=38K,0x39=39K
    d = ((uint32_t)(_Data[6] >> 4) * 10 + (uint32_t)(_Data[6] & 0x0F));
	d |= ((uint16_t)(1) << 8);
    *p_step = 1; return d & 0xFFFE;
    step______1:
    
    while (chr != 0) 
    {
      switch (chr)
      {
        case 0xC1: /*
          Api_Ir_CarrierSend(_Data[cnt+1],_Data[cnt+2]); */
          d = APP_SW_UC_TO_US(_Data[cnt+1],_Data[cnt+2]);
          *p_step = 2; return d | 0x0001;
          step______2:
          cnt += 3;
        break;
        
        case 0xC2:
          for(j=0;j<_Data[cnt+1];j++)
          {
            //Api_Ir_SpaceSend(0xFF,0xF0);
            d = APP_SW_UC_TO_US(0xFF,0xF0);
            *p_step = 3; return d & 0xFFFE;
            step______3:;
          }
          //Api_Ir_SpaceSend(_Data[cnt+2],_Data[cnt+3]);
          d = APP_SW_UC_TO_US(_Data[cnt+2],_Data[cnt+3]);
          *p_step = 4; return d & 0xFFFE;
          step______4:
          cnt += 4;
        break;

        case 0xC3:
        {
          bits = ((uint16_t)(_Data[cnt + 1]) << 8) + (uint16_t)(_Data[cnt + 2]);
          for(i=0;i<bits;i++)
          {
            if((_Data[5] & 0xf) == 0x00) 
            {
              Bytet = i / 8;
              Bitt = i % 8;
            }
            else
            {
              Bytet = i / 8;
              Bitt = (~(i % 8)) & 0x7;
            }

            Bitt = Math_2N_Table[Bitt];

            if((_Data[cnt+3+Bytet] & Bitt) == 0)
            {
              if((_Data[7] & 0x80) == 0x80)
              { /*
                Api_Ir_CarrierSend(_Data[7] & 0x7F,_Data[8]); */
                d = APP_SW_UC_TO_US(_Data[7] & 0x7F,_Data[8]);
                *p_step = 5; return d | 0x0001;
                step______5:
                //Api_Ir_SpaceSend(_Data[9] & 0x7F,_Data[10]);
                d = APP_SW_UC_TO_US(_Data[9] & 0x7F,_Data[10]);
                *p_step = 6; return d & 0xFFFE;
                step______6:;
              }
              else
              {
                //Api_Ir_SpaceSend(_Data[7] & 0x7F,_Data[8]);
                d = APP_SW_UC_TO_US(_Data[7] & 0x7F,_Data[8]);
                *p_step = 7; return d & 0xFFFE;
                step______7: /*
                Api_Ir_CarrierSend(_Data[9] & 0x7F,_Data[10]); */
                d = APP_SW_UC_TO_US(_Data[9] & 0x7F,_Data[10]);
                *p_step = 8; return d | 0x0001;
                step______8:;
              }
            }
            else 
            {
              if((_Data[11] & 0x80) == 0x80)
              { /*
                Api_Ir_CarrierSend(_Data[11] & 0x7F,_Data[12]); */
                d = APP_SW_UC_TO_US(_Data[11] & 0x7F,_Data[12]);
                *p_step = 9; return d | 0x0001;
                step______9:
                //Api_Ir_SpaceSend(_Data[13] & 0x7F,_Data[14]);
                d = APP_SW_UC_TO_US(_Data[13] & 0x7F,_Data[14]);
                *p_step = 10; return d & 0xFFFE;
                step______10:;
              }
              else
              {
                //Api_Ir_SpaceSend(_Data[11] & 0x7F,_Data[12]);
                d = APP_SW_UC_TO_US(_Data[11] & 0x7F,_Data[12]);
                *p_step = 11; return d & 0xFFFE;
                step______11: /*
                Api_Ir_CarrierSend(_Data[13] & 0x7F,_Data[14]); */
                d = APP_SW_UC_TO_US(_Data[13] & 0x7F,_Data[14]);
                *p_step = 12; return d | 0x0001;
                step______12:;
              }
            }
          }

          if((_Data[5] & 0xF0) == 0)
          { /*
            Api_Ir_CarrierSend(_Data[7] & 0x7F,_Data[8]); */
            d = APP_SW_UC_TO_US(_Data[7] & 0x7F,_Data[8]);
            *p_step = 13; return d | 0x0001;
            step______13:;
          }
          
          bytes = bits / 8;
          if (bits % 8 !=0)
            bytes = bytes+1;
          cnt = (cnt + bytes + 3);

        }
        break;

        default:
        //taskEXIT_CRITICAL();
        //要发送的红外数据格式不正确
		*p_step = 0; return 0;
      }
      chr = _Data[cnt];
    }
    //taskEXIT_CRITICAL();
    *p_step = 0xFFFF; return 1000;
}

#endif  //#if (XT_APP_IRSEND_EN == XT_DEF_ENABLED)
#endif
